package api

import (
	"context"
	"fmt"
	"github.com/square/sharkey/pkg/server/telemetry"
	"net/http"
	"time"

	"github.com/bradleyfalzon/ghinstallation"
	"github.com/robfig/cron/v3"
	"github.com/shurcooL/githubv4"
)

const (
	pageLength = 100
)

func (c *Api) CreateGitHubClient() *githubv4.Client {
	tr := http.DefaultTransport

	// We use a private key generated by GitHub along with the corresponding App ID and Installation ID
	// to authenticate to GitHub
	// https://developer.github.com/apps/building-github-apps/authenticating-with-github-apps/
	// Ghinstallation creates a transport which we give to the githubv4 client for auth
	itr, err := ghinstallation.NewKeyFromFile(
		tr, c.conf.GitHub.AppId, c.conf.GitHub.InstallationId, c.conf.GitHub.PrivateKeyPath)
	if err != nil {
		c.logger.Fatalf("could not read github private key: %s", err)
	}

	return githubv4.NewClient(&http.Client{Transport: itr})
}

func (c *Api) fetchUserMappings() (map[string]string, error) {
	fetchStart := time.Now()
	// Original GraphQL query to retrieve mapping of SAML Identity to GitHub Username
	// query {
	//   organization(login: organization) {
	// 	   samlIdentityProvider {
	//	     externalIdentities(first: 100) {
	//	       edges {
	//		     node {
	//		       guid
	//		       samlIdentity {
	//			     nameId
	//		       }
	//		       user {
	//			     login
	//		       }
	//		     }
	//	       }
	//	     }
	//     }
	//   }
	// }
	var query struct {
		Organization struct {
			SamlIdentityProvider struct {
				ExternalIdentities struct {
					Edges []struct {
						Node struct {
							Guid         githubv4.ID
							SamlIdentity struct {
								NameId githubv4.String
							}
							User struct {
								Login githubv4.String
							}
						}
					}
					PageInfo struct {
						HasNextPage githubv4.Boolean
						EndCursor   githubv4.String
					}
				} `graphql:"externalIdentities(first:$pageLength, after:$cursor)"`
			}
		} `graphql:"organization(login:$organization)"`
	}
	// Variables for the above query
	// Replaces the variables in the graphql extensions above
	// $pageLength corresponds to pageLength below
	variables := map[string]interface{}{
		"organization": githubv4.String(c.conf.GitHub.OrganizationName),
		"cursor":       (*githubv4.String)(nil),
		"pageLength":   githubv4.Int(pageLength),
	}

	mapping := map[string]string{}
	for {
		if err := c.gitHubClient.Query(context.Background(), &query, variables); err != nil {
			return nil, err
		}

		for _, edge := range query.Organization.SamlIdentityProvider.ExternalIdentities.Edges {
			gitLogin := string(edge.Node.User.Login)
			ssoLogin := string(edge.Node.SamlIdentity.NameId)
			if gitLogin != "" && ssoLogin != "" {
				mapping[ssoLogin] = gitLogin
			}
		}

		pageInfo := query.Organization.SamlIdentityProvider.ExternalIdentities.PageInfo
		if !pageInfo.HasNextPage {
			break
		}
		variables["cursor"] = pageInfo.EndCursor
	}

	c.telemetry.Metrics.IncrCounter([]string{telemetry.GitHub, telemetry.Fetch, telemetry.Calls}, 1)
	c.telemetry.Metrics.SetGauge(
		[]string{telemetry.GitHub, telemetry.Fetch, telemetry.Latency}, float32(time.Since(fetchStart).Milliseconds()))
	c.telemetry.Metrics.SetGauge([]string{telemetry.GitHub, telemetry.Fetch, telemetry.Count}, float32(len(mapping)))
	return mapping, nil
}

func (c *Api) updateUserMappings() {
	fetchStart := time.Now()
	mapping, err := c.fetchUserMappings()
	if err != nil {
		c.logger.Errorf("unable to retrieve github mapping: %s", err)
		return
	}

	if err := c.storage.RecordGitHubMapping(mapping); err != nil {
		c.logger.Errorf("unable to record github mapping: %s", err)
	}
	c.telemetry.Metrics.SetGauge(
		[]string{telemetry.GitHub, telemetry.SyncJob, telemetry.Latency},
		float32(time.Since(fetchStart).Milliseconds()))
}

func (c *Api) RetrieveGitHubUsername(ssoIdentity string) (string, error) {
	user, err := c.storage.QueryGitHubMapping(ssoIdentity)

	if err != nil {
		return "", fmt.Errorf("unable to find user %s in github mapping: %s", ssoIdentity, err)
	}

	return user, nil
}

func (c *Api) StartGitHubUserMappingSyncJob() error {
	c.logger.Printf("Starting GitHubUserMappingSyncJob to run every %s", c.conf.GitHub.SyncInterval)
	// The cron doesn't initially run, so we run it first before kick off the cron
	c.updateUserMappings()
	job := cron.New()
	if _, err := job.AddFunc(fmt.Sprintf("@every %s", c.conf.GitHub.SyncInterval), c.updateUserMappings); err != nil {
		return err
	}
	job.Start()

	return nil
}
